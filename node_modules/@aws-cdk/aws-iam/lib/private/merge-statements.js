"use strict";
// IAM Statement merging
//
// See docs/policy-merging.als for a formal model of the logic
// implemented here.
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeStatements = void 0;
const util_1 = require("../util");
const postprocess_policy_document_1 = require("./postprocess-policy-document");
/**
 * Merge as many statements as possible to shrink the total policy doc, modifying the input array in place
 *
 * We compare and merge all pairs of statements (O(N^2) complexity), opportunistically
 * merging them. This is not guaranteed to produce the optimal output, but it's probably
 * Good Enough(tm). If it merges anything, it's at least going to produce a smaller output
 * than the input.
 */
function mergeStatements(statements) {
    const compStatements = statements.map(makeComparable);
    let i = 0;
    while (i < compStatements.length) {
        let didMerge = false;
        for (let j = i + 1; j < compStatements.length; j++) {
            const merged = tryMerge(compStatements[i], compStatements[j]);
            if (merged) {
                compStatements[i] = merged;
                compStatements.splice(j, 1);
                didMerge = true;
                break;
            }
        }
        if (!didMerge) {
            i++;
        }
    }
    return compStatements.map(renderComparable);
}
exports.mergeStatements = mergeStatements;
/**
 * Given two statements, return their merging (if possible)
 *
 * We can merge two statements if:
 *
 * - Their effects are the same
 * - They don't have Sids (not really a hard requirement, but just a simplification and an escape hatch)
 * - Their Conditions are the same
 * - Their NotAction, NotResource and NotPrincipal sets are the same (empty sets is fine).
 * - From their Action, Resource and Principal sets, 2 are subsets of each other
 *   (empty sets are fine).
 */
function tryMerge(a, b) {
    // Effects must be the same
    if (a.effect !== b.effect) {
        return;
    }
    // We don't merge Sids (for now)
    if (a.sid || b.sid) {
        return;
    }
    if (a.conditionString !== b.conditionString) {
        return;
    }
    if (!setEqual(a.notAction, b.notAction) || !setEqual(a.notResource, b.notResource) || !setEqual(a.notPrincipal, b.notPrincipal)) {
        return;
    }
    // We can merge these statements if 2 out of the 3 sets of Action, Resource, Principal
    // are the same.
    const setsEqual = (setEqual(a.action, b.action) ? 1 : 0) +
        (setEqual(a.resource, b.resource) ? 1 : 0) +
        (setEqual(a.principal, b.principal) ? 1 : 0);
    if (setsEqual < 2 || unmergeablePrincipals(a, b)) {
        return;
    }
    return {
        effect: a.effect,
        conditionString: a.conditionString,
        conditionValue: b.conditionValue,
        notAction: a.notAction,
        notPrincipal: a.notPrincipal,
        notResource: a.notResource,
        action: setMerge(a.action, b.action),
        resource: setMerge(a.resource, b.resource),
        principal: setMerge(a.principal, b.principal),
    };
}
/**
 * Calculate and return cached string set representation of the statement elements
 *
 * This is to be able to do comparisons on these sets quickly.
 */
function makeComparable(s) {
    return {
        effect: s.Effect,
        sid: s.Sid,
        action: iamSet(s.Action),
        notAction: iamSet(s.NotAction),
        resource: iamSet(s.Resource),
        notResource: iamSet(s.NotResource),
        principal: principalIamSet(s.Principal),
        notPrincipal: principalIamSet(s.NotPrincipal),
        conditionString: JSON.stringify(s.Condition),
        conditionValue: s.Condition,
    };
    function forceArray(x) {
        return Array.isArray(x) ? x : [x];
    }
    function iamSet(x) {
        if (x == undefined) {
            return {};
        }
        return mkdict(forceArray(x).map(e => [JSON.stringify(e), e]));
    }
    function principalIamSet(x) {
        if (x === undefined) {
            return {};
        }
        if (Array.isArray(x) || typeof x === 'string') {
            x = { [util_1.LITERAL_STRING_KEY]: x };
        }
        if (typeof x === 'object' && x !== null) {
            // Turn { AWS: [a, b], Service: [c] } into [{ AWS: a }, { AWS: b }, { Service: c }]
            const individualPrincipals = Object.entries(x).flatMap(([principalType, value]) => forceArray(value).map(v => ({ [principalType]: v })));
            return iamSet(individualPrincipals);
        }
        return {};
    }
}
/**
 * Return 'true' if the two principals are unmergeable
 *
 * This only happens if one of them is a literal, untyped principal (typically,
 * `Principal: '*'`) and the other one is typed.
 *
 * `Principal: '*'` behaves subtly different than `Principal: { AWS: '*' }` and must
 * therefore be preserved.
 */
function unmergeablePrincipals(a, b) {
    const aHasLiteral = Object.values(a.principal).some(v => util_1.LITERAL_STRING_KEY in v);
    const bHasLiteral = Object.values(b.principal).some(v => util_1.LITERAL_STRING_KEY in v);
    return aHasLiteral !== bHasLiteral;
}
/**
 * Turn a ComparableStatement back into a StatementSchema
 */
function renderComparable(s) {
    return postprocess_policy_document_1.normalizeStatement({
        Effect: s.effect,
        Sid: s.sid,
        Condition: s.conditionValue,
        Action: renderSet(s.action),
        NotAction: renderSet(s.notAction),
        Resource: renderSet(s.resource),
        NotResource: renderSet(s.notResource),
        Principal: renderPrincipalSet(s.principal),
        NotPrincipal: renderPrincipalSet(s.notPrincipal),
    });
    function renderSet(x) {
        // Return as sorted array so that we normalize
        const keys = Object.keys(x).sort();
        return keys.length > 0 ? keys.map(key => x[key]) : undefined;
    }
    function renderPrincipalSet(x) {
        const keys = Object.keys(x).sort();
        // The first level will be an object
        const ret = {};
        for (const key of keys) {
            const principal = x[key];
            if (principal == null || typeof principal !== 'object') {
                throw new Error(`Principal should be an object with a principal type, got: ${principal}`);
            }
            const principalKeys = Object.keys(principal);
            if (principalKeys.length !== 1) {
                throw new Error(`Principal should be an object with 1 key, found keys: ${principalKeys}`);
            }
            const pk = principalKeys[0];
            if (!ret[pk]) {
                ret[pk] = [];
            }
            ret[pk].push(principal[pk]);
        }
        return ret;
    }
}
/**
 * Whether the given sets are equal
 */
function setEqual(a, b) {
    const keysA = Object.keys(a);
    const keysB = Object.keys(b);
    return keysA.length === keysB.length && keysA.every(k => k in b);
}
/**
 * Merge two IAM value sets
 */
function setMerge(x, y) {
    return { ...x, ...y };
}
function mkdict(xs) {
    const ret = {};
    for (const x of xs) {
        ret[x[0]] = x[1];
    }
    return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVyZ2Utc3RhdGVtZW50cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm1lcmdlLXN0YXRlbWVudHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLHdCQUF3QjtBQUN4QixFQUFFO0FBQ0YsOERBQThEO0FBQzlELG9CQUFvQjs7O0FBR3BCLGtDQUE2QztBQUM3QywrRUFBOEY7QUFFOUY7Ozs7Ozs7R0FPRztBQUNILFNBQWdCLGVBQWUsQ0FBQyxVQUE2QjtJQUMzRCxNQUFNLGNBQWMsR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBRXRELElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNWLE9BQU8sQ0FBQyxHQUFHLGNBQWMsQ0FBQyxNQUFNLEVBQUU7UUFDaEMsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBRXJCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNsRCxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzlELElBQUksTUFBTSxFQUFFO2dCQUNWLGNBQWMsQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUM7Z0JBQzNCLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUM1QixRQUFRLEdBQUcsSUFBSSxDQUFDO2dCQUNoQixNQUFNO2FBQ1A7U0FDRjtRQUVELElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDYixDQUFDLEVBQUUsQ0FBQztTQUNMO0tBQ0Y7SUFFRCxPQUFPLGNBQWMsQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUM5QyxDQUFDO0FBdkJELDBDQXVCQztBQUVEOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsU0FBUyxRQUFRLENBQUMs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LENBQUMsQ0FBQztTQUM3QztRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztBQUNILENBQUM7QUFnQ0Q7O0dBRUc7QUFDSCxTQUFTLFFBQVEsQ0FBQyxDQUFjLEVBQUUsQ0FBYztJQUM5QyxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzdCLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0IsT0FBTyxLQUFLLENBQUMsTUFBTSxLQUFLLEtBQUssQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUNuRSxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLFFBQVEsQ0FBQyxDQUFjLEVBQUUsQ0FBYztJQUM5QyxPQUFPLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQztBQUN4QixDQUFDO0FBRUQsU0FBUyxNQUFNLENBQUksRUFBc0I7SUFDdkMsTUFBTSxHQUFHLEdBQXNCLEVBQUUsQ0FBQztJQUNsQyxLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUUsRUFBRTtRQUNsQixHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ2xCO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSUFNIFN0YXRlbWVudCBtZXJnaW5nXG4vL1xuLy8gU2VlIGRvY3MvcG9saWN5LW1lcmdpbmcuYWxzIGZvciBhIGZvcm1hbCBtb2RlbCBvZiB0aGUgbG9naWNcbi8vIGltcGxlbWVudGVkIGhlcmUuXG5cblxuaW1wb3J0IHsgTElURVJBTF9TVFJJTkdfS0VZIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgeyBTdGF0ZW1lbnRTY2hlbWEsIG5vcm1hbGl6ZVN0YXRlbWVudCwgSWFtVmFsdWUgfSBmcm9tICcuL3Bvc3Rwcm9jZXNzLXBvbGljeS1kb2N1bWVudCc7XG5cbi8qKlxuICogTWVyZ2UgYXMgbWFueSBzdGF0ZW1lbnRzIGFzIHBvc3NpYmxlIHRvIHNocmluayB0aGUgdG90YWwgcG9saWN5IGRvYywgbW9kaWZ5aW5nIHRoZSBpbnB1dCBhcnJheSBpbiBwbGFjZVxuICpcbiAqIFdlIGNvbXBhcmUgYW5kIG1lcmdlIGFsbCBwYWlycyBvZiBzdGF0ZW1lbnRzIChPKE5eMikgY29tcGxleGl0eSksIG9wcG9ydHVuaXN0aWNhbGx5XG4gKiBtZXJnaW5nIHRoZW0uIFRoaXMgaXMgbm90IGd1YXJhbnRlZWQgdG8gcHJvZHVjZSB0aGUgb3B0aW1hbCBvdXRwdXQsIGJ1dCBpdCdzIHByb2JhYmx5XG4gKiBHb29kIEVub3VnaCh0bSkuIElmIGl0IG1lcmdlcyBhbnl0aGluZywgaXQncyBhdCBsZWFzdCBnb2luZyB0byBwcm9kdWNlIGEgc21hbGxlciBvdXRwdXRcbiAqIHRoYW4gdGhlIGlucHV0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VTdGF0ZW1lbnRzKHN0YXRlbWVudHM6IFN0YXRlbWVudFNjaGVtYVtdKTogU3RhdGVtZW50U2NoZW1hW10ge1xuICBjb25zdCBjb21wU3RhdGVtZW50cyA9IHN0YXRlbWVudHMubWFwKG1ha2VDb21wYXJhYmxlKTtcblxuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgY29tcFN0YXRlbWVudHMubGVuZ3RoKSB7XG4gICAgbGV0IGRpZE1lcmdlID0gZmFsc2U7XG5cbiAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBjb21wU3RhdGVtZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgbWVyZ2VkID0gdHJ5TWVyZ2UoY29tcFN0YXRlbWVudHNbaV0sIGNvbXBTdGF0ZW1lbnRzW2pdKTtcbiAgICAgIGlmIChtZXJnZWQpIHtcbiAgICAgICAgY29tcFN0YXRlbWVudHNbaV0gPSBtZXJnZWQ7XG4gICAgICAgIGNvbXBTdGF0ZW1lbnRzLnNwbGljZShqLCAxKTtcbiAgICAgICAgZGlkTWVyZ2UgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWRpZE1lcmdlKSB7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbXBTdGF0ZW1lbnRzLm1hcChyZW5kZXJDb21wYXJhYmxlKTtcbn1cblxuLyoqXG4gKiBHaXZlbiB0d28gc3RhdGVtZW50cywgcmV0dXJuIHRoZWlyIG1lcmdpbmcgKGlmIHBvc3NpYmxlKVxuICpcbiAqIFdlIGNhbiBtZXJnZSB0d28gc3RhdGVtZW50cyBpZjpcbiAqXG4gKiAtIFRoZWlyIGVmZmVjdHMgYXJlIHRoZSBzYW1lXG4gKiAtIFRoZXkgZG9uJ3QgaGF2ZSBTaWRzIChub3QgcmVhbGx5IGEgaGFyZCByZXF1aXJlbWVudCwgYnV0IGp1c3QgYSBzaW1wbGlmaWNhdGlvbiBhbmQgYW4gZXNjYXBlIGhhdGNoKVxuICogLSBUaGVpciBDb25kaXRpb25zIGFyZSB0aGUgc2FtZVxuICogLSBUaGVpciBOb3RBY3Rpb24sIE5vdFJlc291cmNlIGFuZCBOb3RQcmluY2lwYWwgc2V0cyBhcmUgdGhlIHNhbWUgKGVtcHR5IHNldHMgaXMgZmluZSkuXG4gKiAtIEZyb20gdGhlaXIgQWN0aW9uLCBSZXNvdXJjZSBhbmQgUHJpbmNpcGFsIHNldHMsIDIgYXJlIHN1YnNldHMgb2YgZWFjaCBvdGhlclxuICogICAoZW1wdHkgc2V0cyBhcmUgZmluZSkuXG4gKi9cbmZ1bmN0aW9uIHRyeU1lcmdlKGE6IENvbXBhcmFibGVTdGF0ZW1lbnQsIGI6IENvbXBhcmFibGVTdGF0ZW1lbnQpOiBDb21wYXJhYmxlU3RhdGVtZW50IHwgdW5kZWZpbmVkIHtcbiAgLy8gRWZmZWN0cyBtdXN0IGJlIHRoZSBzYW1lXG4gIGlmIChhLmVmZmVjdCAhPT0gYi5lZmZlY3QpIHsgcmV0dXJuOyB9XG4gIC8vIFdlIGRvbid0IG1lcmdlIFNpZHMgKGZvciBub3cpXG4gIGlmIChhLnNpZCB8fCBiLnNpZCkgeyByZXR1cm47IH1cblxuICBpZiAoYS5jb25kaXRpb25TdHJpbmcgIT09IGIuY29uZGl0aW9uU3RyaW5nKSB7IHJldHVybjsgfVxuICBpZiAoIXNldEVxdWFsKGEubm90QWN0aW9uLCBiLm5vdEFjdGlvbikgfHwgIXNldEVxdWFsKGEubm90UmVzb3VyY2UsIGIubm90UmVzb3VyY2UpIHx8ICFzZXRFcXVhbChhLm5vdFByaW5jaXBhbCwgYi5ub3RQcmluY2lwYWwpKSB7IHJldHVybjsgfVxuXG4gIC8vIFdlIGNhbiBtZXJnZSB0aGVzZSBzdGF0ZW1lbnRzIGlmIDIgb3V0IG9mIHRoZSAzIHNldHMgb2YgQWN0aW9uLCBSZXNvdXJjZSwgUHJpbmNpcGFsXG4gIC8vIGFyZSB0aGUgc2FtZS5cbiAgY29uc3Qgc2V0c0VxdWFsID0gKHNldEVxdWFsKGEuYWN0aW9uLCBiLmFjdGlvbikgPyAxIDogMCkgK1xuICAgIChzZXRFcXVhbChhLnJlc291cmNlLCBiLnJlc291cmNlKSA/IDEgOiAwKSArXG4gICAgKHNldEVxdWFsKGEucHJpbmNpcGFsLCBiLnByaW5jaXBhbCkgPyAxIDogMCk7XG5cbiAgaWYgKHNldHNFcXVhbCA8IDIgfHwgdW5tZXJnZWFibGVQcmluY2lwYWxzKGEsIGIpKSB7IHJldHVybjsgfVxuXG4gIHJldHVybiB7XG4gICAgZWZmZWN0OiBhLmVmZmVjdCxcbiAgICBjb25kaXRpb25TdHJpbmc6IGEuY29uZGl0aW9uU3RyaW5nLFxuICAgIGNvbmRpdGlvblZhbHVlOiBiLmNvbmRpdGlvblZhbHVlLFxuICAgIG5vdEFjdGlvbjogYS5ub3RBY3Rpb24sXG4gICAgbm90UHJpbmNpcGFsOiBhLm5vdFByaW5jaXBhbCxcbiAgICBub3RSZXNvdXJjZTogYS5ub3RSZXNvdXJjZSxcblxuICAgIGFjdGlvbjogc2V0TWVyZ2UoYS5hY3Rpb24sIGIuYWN0aW9uKSxcbiAgICByZXNvdXJjZTogc2V0TWVyZ2UoYS5yZXNvdXJjZSwgYi5yZXNvdXJjZSksXG4gICAgcHJpbmNpcGFsOiBzZXRNZXJnZShhLnByaW5jaXBhbCwgYi5wcmluY2lwYWwpLFxuICB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBhbmQgcmV0dXJuIGNhY2hlZCBzdHJpbmcgc2V0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdGF0ZW1lbnQgZWxlbWVudHNcbiAqXG4gKiBUaGlzIGlzIHRvIGJlIGFibGUgdG8gZG8gY29tcGFyaXNvbnMgb24gdGhlc2Ugc2V0cyBxdWlja2x5LlxuICovXG5mdW5jdGlvbiBtYWtlQ29tcGFyYWJsZShzOiBTdGF0ZW1lbnRTY2hlbWEpOiBDb21wYXJhYmxlU3RhdGVtZW50IHtcbiAgcmV0dXJuIHtcbiAgICBlZmZlY3Q6IHMuRWZmZWN0LFxuICAgIHNpZDogcy5TaWQsXG4gICAgYWN0aW9uOiBpYW1TZXQocy5BY3Rpb24pLFxuICAgIG5vdEFjdGlvbjogaWFtU2V0KHMuTm90QWN0aW9uKSxcbiAgICByZXNvdXJjZTogaWFtU2V0KHMuUmVzb3VyY2UpLFxuICAgIG5vdFJlc291cmNlOiBpYW1TZXQocy5Ob3RSZXNvdXJjZSksXG4gICAgcHJpbmNpcGFsOiBwcmluY2lwYWxJYW1TZXQocy5QcmluY2lwYWwpLFxuICAgIG5vdFByaW5jaXBhbDogcHJpbmNpcGFsSWFtU2V0KHMuTm90UHJpbmNpcGFsKSxcbiAgICBjb25kaXRpb25TdHJpbmc6IEpTT04uc3RyaW5naWZ5KHMuQ29uZGl0aW9uKSxcbiAgICBjb25kaXRpb25WYWx1ZTogcy5Db25kaXRpb24sXG4gIH07XG5cbiAgZnVuY3Rpb24gZm9yY2VBcnJheTxBPih4OiBBIHwgQXJyYXk8QT4pOiBBcnJheTxBPiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCkgPyB4IDogW3hdO1xuICB9XG5cbiAgZnVuY3Rpb24gaWFtU2V0KHg6IElhbVZhbHVlIHwgdW5kZWZpbmVkKTogSWFtVmFsdWVTZXQge1xuICAgIGlmICh4ID09IHVuZGVmaW5lZCkgeyByZXR1cm4ge307IH1cbiAgICByZXR1cm4gbWtkaWN0KGZvcmNlQXJyYXkoeCkubWFwKGUgPT4gW0pTT04uc3RyaW5naWZ5KGUpLCBlXSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbmNpcGFsSWFtU2V0KHg6IElhbVZhbHVlIHwgUmVjb3JkPHN0cmluZywgSWFtVmFsdWU+IHwgdW5kZWZpbmVkKTogSWFtVmFsdWVTZXQge1xuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHt9OyB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh4KSB8fCB0eXBlb2YgeCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHggPSB7IFtMSVRFUkFMX1NUUklOR19LRVldOiB4IH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKSB7XG4gICAgICAvLyBUdXJuIHsgQVdTOiBbYSwgYl0sIFNlcnZpY2U6IFtjXSB9IGludG8gW3sgQVdTOiBhIH0sIHsgQVdTOiBiIH0sIHsgU2VydmljZTogYyB9XVxuICAgICAgY29uc3QgaW5kaXZpZHVhbFByaW5jaXBhbHMgPSBPYmplY3QuZW50cmllcyh4KS5mbGF0TWFwKChbcHJpbmNpcGFsVHlwZSwgdmFsdWVdKSA9PiBmb3JjZUFycmF5KHZhbHVlKS5tYXAodiA9PiAoeyBbcHJpbmNpcGFsVHlwZV06IHYgfSkpKTtcbiAgICAgIHJldHVybiBpYW1TZXQoaW5kaXZpZHVhbFByaW5jaXBhbHMpO1xuICAgIH1cbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gJ3RydWUnIGlmIHRoZSB0d28gcHJpbmNpcGFscyBhcmUgdW5tZXJnZWFibGVcbiAqXG4gKiBUaGlzIG9ubHkgaGFwcGVucyBpZiBvbmUgb2YgdGhlbSBpcyBhIGxpdGVyYWwsIHVudHlwZWQgcHJpbmNpcGFsICh0eXBpY2FsbHksXG4gKiBgUHJpbmNpcGFsOiAnKidgKSBhbmQgdGhlIG90aGVyIG9uZSBpcyB0eXBlZC5cbiAqXG4gKiBgUHJpbmNpcGFsOiAnKidgIGJlaGF2ZXMgc3VidGx5IGRpZmZlcmVudCB0aGFuIGBQcmluY2lwYWw6IHsgQVdTOiAnKicgfWAgYW5kIG11c3RcbiAqIHRoZXJlZm9yZSBiZSBwcmVzZXJ2ZWQuXG4gKi9cbmZ1bmN0aW9uIHVubWVyZ2VhYmxlUHJpbmNpcGFscyhhOiBDb21wYXJhYmxlU3RhdGVtZW50LCBiOiBDb21wYXJhYmxlU3RhdGVtZW50KSB7XG4gIGNvbnN0IGFIYXNMaXRlcmFsID0gT2JqZWN0LnZhbHVlcyhhLnByaW5jaXBhbCkuc29tZSh2ID0+IExJVEVSQUxfU1RSSU5HX0tFWSBpbiB2KTtcbiAgY29uc3QgYkhhc0xpdGVyYWwgPSBPYmplY3QudmFsdWVzKGIucHJpbmNpcGFsKS5zb21lKHYgPT4gTElURVJBTF9TVFJJTkdfS0VZIGluIHYpO1xuICByZXR1cm4gYUhhc0xpdGVyYWwgIT09IGJIYXNMaXRlcmFsO1xufVxuXG4vKipcbiAqIFR1cm4gYSBDb21wYXJhYmxlU3RhdGVtZW50IGJhY2sgaW50byBhIFN0YXRlbWVudFNjaGVtYVxuICovXG5mdW5jdGlvbiByZW5kZXJDb21wYXJhYmxlKHM6IENvbXBhcmFibGVTdGF0ZW1lbnQpOiBTdGF0ZW1lbnRTY2hlbWEge1xuICByZXR1cm4gbm9ybWFsaXplU3RhdGVtZW50KHtcbiAgICBFZmZlY3Q6IHMuZWZmZWN0LFxuICAgIFNpZDogcy5zaWQsXG4gICAgQ29uZGl0aW9uOiBzLmNvbmRpdGlvblZhbHVlLFxuICAgIEFjdGlvbjogcmVuZGVyU2V0KHMuYWN0aW9uKSxcbiAgICBOb3RBY3Rpb246IHJlbmRlclNldChzLm5vdEFjdGlvbiksXG4gICAgUmVzb3VyY2U6IHJlbmRlclNldChzLnJlc291cmNlKSxcbiAgICBOb3RSZXNvdXJjZTogcmVuZGVyU2V0KHMubm90UmVzb3VyY2UpLFxuICAgIFByaW5jaXBhbDogcmVuZGVyUHJpbmNpcGFsU2V0KHMucHJpbmNpcGFsKSxcbiAgICBOb3RQcmluY2lwYWw6IHJlbmRlclByaW5jaXBhbFNldChzLm5vdFByaW5jaXBhbCksXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHJlbmRlclNldCh4OiBJYW1WYWx1ZVNldCk6IElhbVZhbHVlIHwgdW5kZWZpbmVkIHtcbiAgICAvLyBSZXR1cm4gYXMgc29ydGVkIGFycmF5IHNvIHRoYXQgd2Ugbm9ybWFsaXplXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHgpLnNvcnQoKTtcbiAgICByZXR1cm4ga2V5cy5sZW5ndGggPiAwID8ga2V5cy5tYXAoa2V5ID0+IHhba2V5XSkgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJQcmluY2lwYWxTZXQoeDogSWFtVmFsdWVTZXQpOiBSZWNvcmQ8c3RyaW5nLCBJYW1WYWx1ZT4ge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh4KS5zb3J0KCk7XG4gICAgLy8gVGhlIGZpcnN0IGxldmVsIHdpbGwgYmUgYW4gb2JqZWN0XG4gICAgY29uc3QgcmV0OiBSZWNvcmQ8c3RyaW5nLCBJYW1WYWx1ZT4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBjb25zdCBwcmluY2lwYWwgPSB4W2tleV07XG4gICAgICBpZiAocHJpbmNpcGFsID09IG51bGwgfHwgdHlwZW9mIHByaW5jaXBhbCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcmluY2lwYWwgc2hvdWxkIGJlIGFuIG9iamVjdCB3aXRoIGEgcHJpbmNpcGFsIHR5cGUsIGdvdDogJHtwcmluY2lwYWx9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcmluY2lwYWxLZXlzID0gT2JqZWN0LmtleXMocHJpbmNpcGFsKTtcbiAgICAgIGlmIChwcmluY2lwYWxLZXlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByaW5jaXBhbCBzaG91bGQgYmUgYW4gb2JqZWN0IHdpdGggMSBrZXksIGZvdW5kIGtleXM6ICR7cHJpbmNpcGFsS2V5c31gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBrID0gcHJpbmNpcGFsS2V5c1swXTtcbiAgICAgIGlmICghcmV0W3BrXSkge1xuICAgICAgICByZXRbcGtdID0gW107XG4gICAgICB9XG4gICAgICAocmV0W3BrXSBhcyBJYW1WYWx1ZVtdKS5wdXNoKHByaW5jaXBhbFtwa10pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG59XG5cbi8qKlxuICogQW4gYW5hbHl6ZWQgdmVyc2lvbiBvZiBhIHN0YXRlbWVudCB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBkbyBjb21wYXJpc29ucyBhbmQgbWVyZ2luZyBvblxuICpcbiAqIFdlIHdpbGwgc3RyaW5naWZ5IHBhcnRzIG9mIHRoZSBzdGF0ZW1lbnQ6IGNvbXBhcmlzb25zIGFyZSBkb25lIG9uIHRoZSBzdHJpbmdzLCB0aGUgb3JpZ2luYWxcbiAqIHZhbHVlcyBhcmUgcmV0YWluZWQgc28gd2UgY2FuIHN0aXRjaCB0aGVtIGJhY2sgdG9nZXRoZXIgaW50byBhIHJlYWwgcG9saWN5LlxuICovXG5pbnRlcmZhY2UgQ29tcGFyYWJsZVN0YXRlbWVudCB7XG4gIHJlYWRvbmx5IGVmZmVjdD86IHN0cmluZztcbiAgcmVhZG9ubHkgc2lkPzogc3RyaW5nO1xuXG4gIHJlYWRvbmx5IHByaW5jaXBhbDogSWFtVmFsdWVTZXQ7XG4gIHJlYWRvbmx5IG5vdFByaW5jaXBhbDogSWFtVmFsdWVTZXQ7XG4gIHJlYWRvbmx5IGFjdGlvbjogSWFtVmFsdWVTZXQ7XG4gIHJlYWRvbmx5IG5vdEFjdGlvbjogSWFtVmFsdWVTZXQ7XG4gIHJlYWRvbmx5IHJlc291cmNlOiBJYW1WYWx1ZVNldDtcbiAgcmVhZG9ubHkgbm90UmVzb3VyY2U6IElhbVZhbHVlU2V0O1xuXG4gIHJlYWRvbmx5IGNvbmRpdGlvblN0cmluZzogc3RyaW5nO1xuICByZWFkb25seSBjb25kaXRpb25WYWx1ZTogYW55O1xufVxuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBjb21wYXJhYmxlIElBTSB2YWx1ZXNcbiAqXG4gKiBFYWNoIHZhbHVlIGlzIGluZGV4ZWQgYnkgaXRzIHN0cmluZ2lmaWVkIHZhbHVlLCBtYXBwaW5nIHRvIGl0cyBvcmlnaW5hbCB2YWx1ZS5cbiAqIFRoaXMgYWxsb3dzIHVzIHRvIGNvbXBhcmUgdmFsdWVzIHF1aWNrbHkgYW5kIGVhc2lseSAoZXZlbiBpZiB0aGV5IGFyZSBjb21wbGV4KSxcbiAqIHdoaWxlIGFsc28gYmVpbmcgYWJsZSB0byBkZWR1cGxpY2F0ZSB0aGUgb3JpZ2luYWxzLlxuICovXG50eXBlIElhbVZhbHVlU2V0ID0gUmVjb3JkPHN0cmluZywgYW55PjtcblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBnaXZlbiBzZXRzIGFyZSBlcXVhbFxuICovXG5mdW5jdGlvbiBzZXRFcXVhbChhOiBJYW1WYWx1ZVNldCwgYjogSWFtVmFsdWVTZXQpIHtcbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGsgPT4gayBpbiBiKTtcbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gSUFNIHZhbHVlIHNldHNcbiAqL1xuZnVuY3Rpb24gc2V0TWVyZ2UoeDogSWFtVmFsdWVTZXQsIHk6IElhbVZhbHVlU2V0KTogSWFtVmFsdWVTZXQge1xuICByZXR1cm4geyAuLi54LCAuLi55IH07XG59XG5cbmZ1bmN0aW9uIG1rZGljdDxBPih4czogQXJyYXk8W3N0cmluZywgQV0+KTogUmVjb3JkPHN0cmluZywgQT4ge1xuICBjb25zdCByZXQ6IFJlY29yZDxzdHJpbmcsIEE+ID0ge307XG4gIGZvciAoY29uc3QgeCBvZiB4cykge1xuICAgIHJldFt4WzBdXSA9IHhbMV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiJdfQ==